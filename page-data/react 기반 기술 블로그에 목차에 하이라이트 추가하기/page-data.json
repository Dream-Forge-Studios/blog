{"componentChunkName":"component---src-templates-post-template-tsx","path":"/react 기반 기술 블로그에 목차에 하이라이트 추가하기/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>스크롤에 의해 헤더안으로 제목이 가려지면 그에 해당하는 목차에 하이라이트를 하는 기능을 구현해 볼 것이다.</p>\n<p>이 기능을 구현하기 위해선 해당 위치를 파악하여 스크롤에 따라 이벤트를 일으켜야 한다.</p>\n<p>이를 쉽게 구현하기 위한 방법인 Interaction Observer API를 소개할 것이다.</p>\n<div id=\"Interaction Observer API\"></div>\n<h1>Interaction Observer API</h1>\n<div id=\"왜 사용하는가?\"></div>\n<h2>왜 사용하는가?</h2>\n<p>기존 scroll 이벤트는 스크롤을 할 때마다 지속적으로 실행되어 큰 부하를 줄 수 있다.</p>\n<p>하지만 Interaction Observer API는 비동기적으로 원하는 타겟의 가시성이 변경될 때만 이벤트가 실행된다.</p>\n<p>또한 쉽게 구현할 수 있도록 기능이 제공된다.</p>\n<div id=\"사용 방법\"></div>\n<h2>사용 방법</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const observer = new IntersectionObserver(callback, options); // 관찰자 생성\r\nobserver.observe(element); // 관찰 대상 등록</code></pre></div>\n<p>우선 관찰자를 생성한다. options의 값이 충족될 때마다 callback이 호출된다.</p>\n<h3>options의 값</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">root</code></p>\n<br>\r\n대상의 가시성을 확인하기 위한 뷰포트로 사용되는 요소입니다. 대상의 조상이어야 합니다. 지정되지 않거나 null인 경우 브라우저 뷰포트가 기본값입니다.\n<br>\r\n<br>\r\n여기서 뷰포트란 눈에 보이는 화면을 말하는 것이다.\r\n<br>\r\n<br>\n</li>\n<li>\n<p><code class=\"language-text\">rootMargin</code></p>\n<br>\r\n루트 주위에 여백을 둡니다. margin예를 들어 \" (상단, 오른쪽, 하단, 왼쪽) 와 같은 CSS 속성과 유사한 값을 가질 수 있습니다 10px 20px 30px 40px\". 값은 백분율이 될 수 있습니다. 이 값 세트는 교차점을 계산하기 전에 루트 요소 경계 상자의 각 측면을 늘리거나 줄이는 역할을 합니다. 기본값은 모두 0입니다.\n<br>\r\n<br>\n</li>\n<li>\n<p><code class=\"language-text\">threshold</code></p>\n<br>\r\n관찰자의 콜백이 실행되어야 하는 대상의 가시성 비율을 나타내는 단일 숫자 또는 숫자 배열입니다. 가시성이 50% 표시를 통과할 때만 감지하려는 경우 값 0.5를 사용할 수 있습니다. 가시성이 또 다른 25%를 지날 때마다 콜백을 실행하려면 배열 [0, 0.25, 0.5, 0.75, 1]을 지정합니다. 기본값은 0입니다(단 하나의 픽셀이라도 표시되는 즉시 콜백이 실행됨을 의미). 1.0 값은 모든 픽셀이 표시될 때까지 임계값이 통과된 것으로 간주되지 않음을 의미합니다.\n</li>\n</ul>\n<p>위의 옵션값들이 충족되면 callback 함수가 실행된다.</p>\n<p>element에는 관찰하고자 하는 값을 넣어준다. 여기서는 목차에 하이라이트를 해줄 것으로 목차에 들어갈 문장을 넣어준다.</p>\n<h3>목차를 위한 구현 방법</h3>\n<h4>1. 관찰자 생성</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {Dispatch, SetStateAction} from 'react';\r\n\r\nconst observerOption = {\r\n    threshold: 0.4,\r\n    rootMargin: '-60px 0px 0px 0px',\r\n};\r\n\r\nexport const getIntersectionObserver = (setState: Dispatch&lt;SetStateAction&lt;string>>) => {\r\n    let direction = '';\r\n    let prevYposition = 0;\r\n\r\n    // scroll 방향 check function\r\n    const checkScrollDirection = (prevY: number) => {\r\n        if (window.scrollY === 0 &amp;&amp; prevY === 0) return;\r\n        else if (window.scrollY > prevY) direction = 'down';\r\n        else direction = 'up';\r\n\r\n        prevYposition = window.scrollY;\r\n    };\r\n\r\n    // observer\r\n    const observer = new IntersectionObserver((entries) => {\r\n        entries.forEach((entry) => {\r\n            checkScrollDirection(prevYposition);\r\n            if ((direction === 'down' &amp;&amp; !entry.isIntersecting) ||\r\n                (direction === 'up' &amp;&amp; entry.isIntersecting)) {\r\n                setState(entry.target.innerHTML);\r\n            }\r\n        });\r\n    }, observerOption);\r\n\r\n    return observer;\r\n}</code></pre></div>\n<p>나는 헤더에 제목이 가려질 때 목차에 하이라이트를 해줄 것이므로 헤더의 높이인 60px를 rootMargin에 넣어주었다.</p>\n<p>threshold는 이런 저런 값을 넣어보니 0.4가 해당 기능에 적절하였다.</p>\n<p>특정 대상이 없기 때문에 root는 지정하지 않았다.</p>\n<p>callback 함수의 관해서는 scroll 방향을 체크하였고,</p>\n<ul>\n<li>entries 값\n<ul>\n<li><code class=\"language-text\">boundingClientRect</code> : 관찰 대상의 사각형 정보(DOMRectReadOnly)</li>\n<li><code class=\"language-text\">intersectionRect</code> : 관찰 대상의 교차한 영역 정보(DOMRectReadOnly)</li>\n<li><code class=\"language-text\">intersectionRatio</code> : 관찰 대상의 교차한 영역 백분율(intersectionRect 영역에서 boundingClientRect 영역까지 비율, Number)</li>\n<li><code class=\"language-text\">isIntersecting</code> : 관찰 대상의 교차 상태(Boolean)</li>\n<li><code class=\"language-text\">rootBounds</code> : 지정한 루트 요소의 사각형 정보(DOMRectReadOnly)</li>\n<li><code class=\"language-text\">target</code> : 관찰 대상 요소(Element)</li>\n<li><code class=\"language-text\">time</code> : 변경이 발생한 시간 정보(DOMHighResTimeStamp)</li>\n</ul>\n</li>\n</ul>\n<p>에서 isIntersecting를 활용하여 관찰 대상이 들어올 때(<code class=\"language-text\">true</code>)는 스크롤을 올릴 때, 관찰 대상이 나갈 때(<code class=\"language-text\">false</code>)는 스크롤을 내릴 때의 조건으로 하였다.\r\n<br>\r\n<br></p>\n<h4>2. 관찰 대상 설정</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const PostContent: FunctionComponent&lt;PostContentProps> = function ({ html }) {\r\n\r\n    const [currentInnerHTML, setCurrentInnerHTML] = useState&lt;string>(''); //현재 목차\r\n    const [headingEls, setHeadingEls] = useState&lt;Element[]>([]); //관찰 대상\r\n\r\n    useEffect(() => {\r\n        const observer = getIntersectionObserver(setCurrentInnerHTML);\r\n        const headingElements = Array.from(document.querySelectorAll('h1, h2'));\r\n        setHeadingEls(headingElements);\r\n        headingElements.map((header) => {\r\n            observer.observe(header);\r\n        });\r\n    }, []);\r\n    console.log(currentInnerHTML)\r\n\r\n    return (\r\n        &lt;ContentWrapper>\r\n            &lt;MarkdownRenderer dangerouslySetInnerHTML={{ __html: html }} />\r\n            &lt;Toc>\r\n                &lt;Toc2>\r\n            {headingEls.map((a) => {\r\n                let HighLight: boolean = false;\r\n                if (currentInnerHTML == a.innerHTML){\r\n                    HighLight = true;\r\n                }\r\n\r\n                if (a.tagName == 'H1'){\r\n                    return &lt;H1 HighLight={HighLight}>{a.innerHTML}&lt;/H1>\r\n                }\r\n                else if (a.tagName == 'H2') {\r\n                    return &lt;H2 HighLight={HighLight}>{a.innerHTML}&lt;/H2>\r\n                }\r\n                }\r\n            )}\r\n                &lt;/Toc2>\r\n            &lt;/Toc>\r\n        &lt;/ContentWrapper>\r\n    )\r\n}\r\n\r\nexport default PostContent</code></pre></div>\n<p>h1과 h2 태그를 관찰 대상으로 정하였고, 현재 목차와 관찰 대상이 같으면 하이라이트를 주었다.\r\n<br>\r\n<br></p>\n<p><a href=\"https://heropy.blog/2019/10/27/intersection-observer/\" target=\"_blank\" rel=\"nofollow\">Interaction Observer API를 좀 더 자세히 알고싶다면</a></p>","frontmatter":{"title":"react 기반 기술 블로그에 목차에 하이라이트 추가하기","summary":"Interaction Observer API를 활용하여 다양한 기능을 가지고 있는 동적 목차를 추가해보자.","date":"2023.02.16.","categories":["WEB/APP"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEZklEQVR42j2TCU8bVxDH9wNUvRRE1IQkrTh87PpcY0OIACGaqmoKSJFCA4ratFVDOJoAbShpEVcSEQg4YByccBgaKBgM5rC963O959tdr20gBkSq9qv0EaRKT6N5evrp/5+ZN0j151/gRo0Vx8pseJnNbMP1Zr3GgBah6nyLCRsbs8di8VA4Go8nGJbnOEEQRAAkUZRhRCoqq2zFeiuOXraZS63GElxvMWiMmArV5BebsOf28TiViERiFEWfwjwPIC8ACSZISemV8itWo05lxQ3FZoNRrzWgapNOhUHYiI2POyAWjsTiFE1DmAenMDiFTSa8orxMpy2wmPTwGHVaVF2IaQpObBsxh2Pyf5h5B5/IChKMMEdQFCsrK1UXfWrUo2YDZtBpMG2RujBfq8rHT5THw+FIMBiCPJVgGIZjT8zzLMsmEjSiRXUohkKdYrPOYkRNek1RwaWi/M8uXcgzYWr7mH17eydEkhRFwXJFIAABqvMCz8WiEaSgUGOx4MUmFLbKgKrOnc358P33Pv7og/qaamF7WiCXiIA/CYS0LO0qyTeZdHYvc/hmL7ub5hNxJCc3r6KiHJrMO/cJqtXU1V7Lzc2xGlS+lwNLjgHfVN/KrDOTlAHLSDwn8pzEswoQUiIPr8iZM2fP513EcUtHZ/uGz3twuLeyvDjy8M7wr9+vTo8+aPlpYqj/aD8jMicwJNl4TEhQgGFiIRIxmS0XLhY8HHgKW5g9SO1m0qzknbf/3Hnr676OHwf/6PK4XUf7u1AqKfApwAMmARg6Hg75N31IZWXVjMsVIYJPno5u7mylFMGx0vR7X03r9er6St3zwVY6sg3JjAwykrCXFCHPURSXoOhoGKmtrYuQ/sNdJSPxrlevJhc7+53XG1v1N25it78z9A7WhcitKOGPEH7YIeVEmYLOZY6TORZpbm4Ok8FEggGi4vP5Oga+bH9c9e09w602rKnb+EvvtUAgGCLDm+veTe9KIhKiwmQkGIiHSBqOqqfnt/U1D8tJHJBpGnTea+gaqW5o0TXexWpuFH5z2wp/JMXKKx7v0p/uDc/Sltez5V3bXl+DCdLa0rSxuhwORYGcTqWzronH3aNXq2vUZlxVbCv4qh4jAuubo22+sVbvutc9O/vaPTczNbkw8/KvBTdSWVG+uvya8O/EKfbg8B8yTtzts/3QdrXxZr21RFNaef5+c0N7jXlu6AHD8AQZDRDheffC2PCQffgJXAzLYF+P17M8NzMN32iWcb5sn50f8a77Rp4NdXfcmbA/o1hp/+BvJbXLC7Isp3leJoio68UUYrRchiJOx/j87PTc9DTgBZFYySip/ezx4dHb47f/Zg+OFSUtAjkJByKl4Eq922qJoQHS2fXIpNfdb2ueck5srHpIMsrxopLa298/lJNpUUrCvYUxmcyIkgITjoO/i4MlxKI04l5YLbfqK0pMj/p7XzgmXE7n/MIiw0IgJQBoUpEkBQA4V8BxIsuJ8ImiGJKIbG36/wPG3qQZ7mlVkwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/3672896cbb49cb2a4050c9744a3e8496/d89b0/test.jpg","srcSet":"/static/3672896cbb49cb2a4050c9744a3e8496/aaa13/test.jpg 374w,\n/static/3672896cbb49cb2a4050c9744a3e8496/b3c6b/test.jpg 748w,\n/static/3672896cbb49cb2a4050c9744a3e8496/d89b0/test.jpg 1496w","sizes":"(min-width: 1496px) 1496px, 100vw"},"sources":[{"srcSet":"/static/3672896cbb49cb2a4050c9744a3e8496/0dfd6/test.webp 374w,\n/static/3672896cbb49cb2a4050c9744a3e8496/8acfa/test.webp 748w,\n/static/3672896cbb49cb2a4050c9744a3e8496/06565/test.webp 1496w","type":"image/webp","sizes":"(min-width: 1496px) 1496px, 100vw"}]},"width":1496,"height":1496}},"publicURL":"/static/3672896cbb49cb2a4050c9744a3e8496/test.png"}}}}]}},"pageContext":{"slug":"/react 기반 기술 블로그에 목차에 하이라이트 추가하기/"}},"staticQueryHashes":[],"slicesMap":{}}